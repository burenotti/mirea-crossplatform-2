#import "./template/template.typ": *

#show: project.with(
  title: "Отчёт по практической работе №3",
  theme: "",
  department: "Математического обеспечения и стандартизации информационных технологий",
  course: "Разработка кроссплатформенных мобильных приложений",
  authors: (
    "Буренин А.А.",
  ),
  lecturer: "Шешуков Л.С.",
  lecturer_grade: "Старший преподаватель кафедры МОСИТ",
  group: "ИКБО-07-22",
  date: datetime.today(),
  add_toc: false,
)

#let img(path) = "./imgs/" + path + ".png"

= План работы

- Знакомство с основным перечнем часто применяемых виджетов
- Создание собственных Widget-ов на основе StatelessWidget
- Создание собственных Widget-ов на основе StatefulWidget
- Выполнение практической работы №3
= Ход работы

== Знакомство с основным перечнем часто применяемых виджетов
Перечень используемых Widget-ов в разработке реальных приложений
очень вариативен и разнообразен, однако есть основной перечень, который
применяется чаще всего.

Набор базовых компонентов для разработки приложений отличается
большим многообразием и гибкостью применения. При этом существует
фундаментальный список элементов, который наиболее часто используется в
практике разработки. Эти базовые строительные блоки, хоть и редко
применяются изолированно друг от друга, каждый обладает уникальным
функционалом и специфической характеристикой. Давайте детально разберем
каждый из этих компонентов:

== Text
Данный Widget используется для отображения текстовой информации
на экране приложения. Его сигнатура достаточно проста (рисунок 1), в
качестве обязательного параметра Widget Text требует строку или строковое
значение, которое он будет отображать на экране. В качестве не обязательных
параметров Widget Text имеет в своей сигнатуре: style – описание стиля
выводимого на экран стиля, textAlign – используется для выравнивания текста
относительно контейнера и т.д.


Рисунок 1 – Сигнатура Widget-а Text

== Elevated Button
Во многих мобильных и веб-приложениях крайне важно обеспечить
удобное взаимодействие пользователей с интерфейсом. Одним из ключевых
элементов такого взаимодействия являются разнообразные типы кнопок.
Фреймворк Flutter предлагает разработчикам широкий спектр возможностей
для реализации кнопок, среди которых особое внимание привлекает
стандартная кнопка – ElevatedButton.
Этот элемент представляет собой интерактивную область,
предназначенную для реагирования на касания пользователя. Пользователи
нажимают на нее, вызывая соответствующие события и изменения внутри
приложения. Кнопка обладает множеством настраиваемых свойств (рисунок
2), позволяющих изменять ее внешний вид и поведение.

Параметры ElevatedButton:
- onPressed: Этот обязательный параметр определяет функцию-
обработчик, которая запускается при однократном нажатии на кнопку. Без
задания обработчика кнопка станет неактивной и не сможет реагировать на
клики.
- child: это также обязательное свойство, которое обозначает контент,
отображаемый внутри самой кнопки. В качестве содержимого можно передать
практически любой другой виджет, будь то текст, иконка или даже целый
контейнер с вложенными элементами. Таким образом, возможности
наполнения кнопки зависят лишь от размеров экрана устройства и фантазии
разработчика.
Помимо этих двух основных параметров, существует ряд
необязательных аргументов, позволяющих настроить дополнительные
свойства поведения и внешнего вида кнопки
- onLongPress: определяет обработку длительного удерживания пальца
на кнопке. Если этот обработчик не задан, то длительное нажатие будет
игнорироваться системой.
- style: Параметр, задающий визуальное оформление кнопки. Здесь
можно установить цвета фона, границы, форму углов и тени. Если стили не
указаны вручную, кнопка наследует стандартные настройки оформления,
установленные в приложении.
Рисунок 2 – Сигнатура ElevatedButton4
== Column
Контейнер Column во Flutter располагает элементы вертикально,
заполняя всю доступную высоту экрана. Он не поддерживает автоматическую
прокрутку, поэтому при большом количестве элементов рекомендуется
использовать ListView.
Основные параметры Column (рисунок 3):
- mainAxisAlignment: выравнивание по вертикали.
- mainAxisSize: размер контейнера по высоте.
- crossAxisAlignment: выравнивание по горизонтали.
- children: список вложенных элементов.
Таким образом, Column удобен для простой вертикальной компоновки,
но требует внимания при работе с большими списками.
Рисунок 3 – Сигнатура виджета Column
== Row

Для размещения элементов не по вертикали, а по горизонтали, вместо
Column используется Widget Row. Его основные свойства абсолютно
аналогичны Widget-у Column. Row так же занимает все свободное
горизонтальное пространство, если ему не установлена другая логика
параметром mainAxisSize, а также не имеет прокрутку, что соответственно
обязует вместить все содержимое в выделенную область. Сигнатура Widget-а
Row, изображенная на рисунке 4, так же схожа с сигнатурой Widget-а Column,
за исключением векторов указания: mainAxisAlignment: задает выравнивание
по горизонтали, mainAxisSize: задает пространство, занимаемое виджетом по
горизонтали, crossAxisAlignment: задает выравнивание по вертикали, а
children задает набор вложенных элементов.
Рисунок 4 – Сигнатура виджета Row

== SizedBox

SizedBox во Flutter применяется для создания виджета фиксированного
размера. Его сигнатура включает два ключевых параметра (рисунок 5):
- width: Ширина контейнера.
- height: Высота контейнера.
Также возможно добавить внутрь любого другого виджета через
параметр child, позволяя легко создавать блоки нужного размера с
произвольным содержанием.
Виджет SizedBox активно используется для формирования отступов и
промежутков между элементами в композициях, организованных в
контейнерах типа Column или Row.
6
Рисунок 5 – Сигнатура виджета SizedBox
1.6 Padding
Для управления отступами элементов в интерфейсе, помимо SizedBox, в
Flutter используется виджет Padding. Этот виджет позволяет создать
дополнительное пространство вокруг вложенного элемента (child) в любом
направлении.
Параметр padding принимает объект класса EdgeInsets,
обеспечивающего настройку отступов различными способами (рисунок 6):
- all(): Устанавливает одинаковый отступ по всем сторонам.
- symmetric(): Позволяет задать симметричные отступы по одной оси
(горизонтально или вертикально).
- horizontal(): Добавляет одинаковые отступы слева и справа.
- vertical(): Применяется для верхнего и нижнего отступов.
- only(): Дает возможность точно задать отступ отдельно для каждой
стороны (слева, справа, сверху, снизу).
Таким образом, Padding подходит для ситуаций, когда требуются точные
или неравномерные отступы, а стандартный SizedBox оказывается
недостаточным решением.
Рисунок 6 – Сигнатура виджета Padding
== Container
Container в Flutter предназначен для хранения единственного
вложенного элемента, предлагая при этом широкие возможности по
изменению его внешнего вида и позиционированию. Этот виджет фактически
объединяет функциональность других базовых виджетов вроде SizedBox,
Padding и прочих, позволяя управлять такими аспектами, как фон, положение
и размер.

Благодаря широкому спектру параметров, представленных в сигнатуре
Container (рисунок 7), разработчики получают полный контроль над внешним
видом компонента.

Основные преимущества включают:
- Настройку размеров и границ.
- Возможность установки цветов фона и градиентов.
- Определение формы угла и теней.
- Задание внутренних и внешних отступов.

Однако такое разнообразие функций имеет и обратную сторону:
использование Container оправдано лишь в тех случаях, когда
специализированные виджеты оказываются недостаточными. Иначе говоря,
если одному элементу нужно одновременно задать размеры, отступы, фон и
прочие характеристики, применение отдельных специализированных
виджетов привело бы к сложной иерархической структуре. В таком сценарии
Container становится оптимальным выбором, сокращающим количество
вложенностей и повышая читаемость кода.

Рисунок 7 – Сигнатура виджета Container

== Создание собственных Widget-ов на основе StatelessWidget
Несмотря на обширный набор готовых виджетов в библиотеке Flutter,
создание сложных интерфейсов нередко требует разделения разметки на
составные части. Разделение верстки улучшает восприятие кода и
способствует повторному использованию компонентов.

Чтобы реализовать такую модульность, разработчики создают
кастомные виджеты, основываясь на стандартных виджетах фреймворка.
Среди базовых типов виджетов выделяются три ключевые категории:
- Stateless Widge: используется для статичных компонентов, не
зависящих от состояния. Отрисовка выполняется методом `build`,
возвращающим финальный виджет.
- Stateful Widget: подходит для динамических элементов, состояние
которых изменяется в процессе работы.
- Inherited Widge: Предназначен для передачи данных между
родительскими и дочерними компонентами.
Рассмотрим принцип работы Stateless Widget:
1. Создается экземпляр виджета и добавляется на экран.
2. Метод build вызывает процесс рендеринга, возвращая структуру
отображаемых элементов.
Пример реализации простого Stateless Widget (рисунок 8)
демонстрируется в новом проекте по умолчанию, наглядно иллюстрируя
базовые принципы разработки собственных компонентов.
Рисунок 8 – Пример реализации StatelessWidget

== Создание собственных Widget-ов на основе StatefulWidget
Часто бывает необходимо изменить виджет на экране в зависимости от
действий пользователя. Виджеты на основе Stateless Widget не подходят для
таких целей, поскольку они лишены внутреннего состояния и не способны
перерисовывать свое представление. После каждого изменения старый виджет
удаляется, а новый создаётся заново.
Решением проблемы является использование Stateful Widget, который
способен хранить своё внутреннее состояние и динамически перестраиваться
при изменениях.

Принцип работы Stateful Widget
Работа с Stateful Widget предполагает наличие двух классов:
- Класс виджета: содержит конфигурационные данные виджета.
- Класс состояния State: хранит внутренние данные и управляет
процессом перерисовки.

Жизненный цикл класса State. Каждый объект State проходит определённый жизненный цикл,
включающий мтоды, управляющие изменением состояний:
- initState: выполняется при первой инициализации виджета, производит
начальные операции.
- setState: позволяет обновить состояние виджета путём вызова
специальной функции, передающей новую версию состояния. Затем виджет
обновляется, сохраняя своё присутствие на экране.
- didUpdateWidget: вызывается при изменении конфигурации виджета.
Получает старую и новую версии виджета и позволяет обновить
представление.
- didChangeDependencies: реагирует на изменение внешних
зависимостей, влияющих на отображение виджета.
Эти механизмы обеспечивают эффективное управление состоянием
виджета и помогают динамично обновлять интерфейс в ответ на действия
пользователя.

Подробнее изучить реализацию и работу Stateful Widget можно в
начальном шаблоне нового проекта, представленного на рисунке 9.

Рисунок 9 – Пример реализации Stateful виджета

== Выполнение практической работы №3

Для выполенения практической работы было реализовано приложение на flutter с 5 различными экранами.

= Вывод
