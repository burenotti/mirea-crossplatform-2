#import "./template/template.typ": *

#show: project.with(
  title: "Отчёт по практической работе №5",
  theme: "",
  department: "Математического обеспечения и стандартизации информационных технологий",
  course: "Разработка кроссплатформенных мобильных приложений",
  authors: (
    "Буренин А.А.",
  ),
  lecturer: "Шешуков Л.С.",
  lecturer_grade: "Старший преподаватель кафедры МОСИТ",
  group: "ИКБО-07-22",
  date: datetime.today(),
  add_toc: false,
)

#let img(path) = "./imgs/" + path + ".png"
#let r(inner, supplement: "рисунке") = ref(inner, supplement: supplement)

= Цель и задание

*Цель работы:* создание структуры проекта и экранных форм, разработка логики и виджетов приложения.

*Задание:* необходимо выбрать индивидуальную тему и подготовить приложение, демонстрирующее реализацию бизнес-логики продукта. В ходе выполнения практического задания студенту нужно предоставить описания логики и выполняемых функций приложения, а также произвести описания принципов его работы. Приложение должно включать в себя обработку пользовательского ввода, работу с данными и вывод информации. Приложение должно состоять из базовых элементов и строится на примитивных системах контроля состояния.

*План практической работы:*
- Выбор темы приложения и определение бизнес-функций
- Подготовка структуры проекта
- Создание экранных форм
- Разработка виджетов
- Реализация логики приложения
- Выполнение практической работы №5

= Ход работы

== Выбор темы приложения и определение бизнес-функций

*Тема:* Приложение для отслеживания привычек (Habit Tracker)

*Исследование целевой аудитории*

Целевая аудитория приложения включает людей, стремящихся к личностному росту и самосовершенствованию через формирование полезных привычек и избавление от вредных. Ключевые группы — студенты, работающие специалисты, люди, занимающиеся саморазвитием, и те, кто борется с вредными привычками.

Студенты заинтересованы в формировании учебных привычек: регулярное чтение, занятия спортом, изучение языков. Работающие специалисты стремятся поддерживать баланс между работой и здоровьем: регулярные тренировки, правильное питание, отказ от вредных привычек. Люди, занимающиеся саморазвитием, используют такие инструменты для отслеживания прогресса в достижении долгосрочных целей. А те, кто хочет избавиться от вредных привычек (курение, переедание, прокрастинация), нуждаются в визуализации своего прогресса и мотивации для поддержания позитивных изменений.

*Анализ пользовательских потребностей*

Современный пользователь стремится эффективно формировать привычки, но часто сталкивается с отсутствием мотивации и визуализации прогресса.

*Основные проблемы:*
- отсутствие наглядного отображения прогресса в формировании привычки;
- сложность отслеживания регулярности выполнения действий;
- недостаток мотивации при достижении промежуточных результатов;
- отсутствие простого инструмента для фиксации выполнения привычки.

Приложение решает эти задачи, предоставляя пользователю удобный способ добавлять привычки, отмечать их выполнение (ack) или пропуск (break), и отслеживать прогресс к целевому количеству дней.

*Определение функциональных требований*

Основная функциональность приложения включает:
- добавление новой привычки (название, иконка, целевое количество дней);
- редактирование существующей привычки;
- отображение списка всех активных привычек;
- отметка выполнения привычки (acknowledgment);
- отметка пропуска привычки (break);
- просмотр статистики по конкретной привычке;
- возможность удаления привычки.

*Разработка бизнес-логики*

При добавлении привычки пользователь вводит название, выбирает визуальную иконку и устанавливает целевое количество дней. Система сохраняет данные в локальной структуре с уникальным идентификатором.

Приложение позволяет: просматривать список привычек с текущим прогрессом, отмечать выполнение или пропуск привычки, отслеживать количество выполнений (acks) и пропусков (breaks), автоматически рассчитывать текущий прогресс как разницу между выполнениями и пропусками, визуально отображать достижение цели. Каждое действие пользователя фиксируется с временной меткой, что позволяет анализировать историю формирования привычки.

== Подготовка структуры проекта

Разработка мобильного приложения для отслеживания привычек на фреймворке Flutter требует выбора оптимальной архитектуры, обеспечивающей простоту, читаемость и легкость сопровождения проекта. Так как приложение является учебным и имеет ограниченный набор функций, наиболее подходящим решением является функционально-ориентированная (feature-based) структура проекта с разделением на сущности (entities), состояние (state), экраны (screens) и виджеты (widgets).

*Описание структуры проекта*

Приложение организовано по следующей структуре:

```
lib/
├── features/
│   ├── entities/
│   │   └── habbit.dart          # Доменная модель привычки
│   ├── state/
│   │   ├── habbits_container.dart  # Контейнер состояния
│   │   └── habbit_model.dart       # Модель для UI
│   ├── screens/
│   │   ├── habbits_list_screen.dart   # Экран списка привычек
│   │   ├── habbit_form_screen.dart    # Форма создания/редактирования
│   │   └── habbit_stats_screen.dart   # Экран статистики
│   └── widgets/
│       ├── habbits_controller.dart  # Интерфейс контроллера
│       ├── habbits_list.dart        # Виджет списка
│       └── habbit_item.dart         # Виджет элемента привычки
└── main.dart                      # Точка входа
```

*Описание компонентов:*

- *entities/habbit.dart* — определяет структуру данных привычки. Это основная сущность предметной области приложения, содержащая бизнес-логику для работы с действиями (ack/break) и расчета прогресса.

- *state/habbits_container.dart* — главный контейнер состояния, управляющий списком привычек и навигацией между экранами. Реализует интерфейс HabbitsController.

- *state/habbit_model.dart* — модель представления для UI, преобразующая доменную сущность в удобный формат для отображения.

- *screens/habbits_list_screen.dart* — отображает список привычек с возможностью добавления новых через FloatingActionButton.

- *screens/habbit_form_screen.dart* — форма для создания и редактирования привычек (название, иконка, целевое количество дней).

- *screens/habbit_stats_screen.dart* — экран детальной статистики по выбранной привычке.

- *widgets/habbits_controller.dart* — абстрактный интерфейс, определяющий все операции с привычками (добавление, удаление, отметка выполнения, навигация).

- *widgets/habbits_list.dart* — виджет для отображения списка привычек в виде прокручиваемого списка.

- *widgets/habbit_item.dart* — отдельный виджет для отображения одной привычки в списке.

Данный подход позволяет сгруппировать все файлы, относящиеся к одной функциональной области — отслеживанию привычек — в пределах одной директории. Это делает кодовую базу логически цельной и интуитивно понятной для разработчика.

*Ключевые архитектурные решения*

*Разделение ответственности*

Приложение следует принципу разделения ответственности:
- *Entities* — содержат бизнес-логику и правила предметной области
- *State* — управляют состоянием приложения
- *Screens* — отвечают за отображение экранов
- *Widgets* — предоставляют переиспользуемые компоненты UI

*Иммутабельность*

Класс Habbit реализован как иммутабельная структура. Все изменения создают новый экземпляр через паттерн `_copyWith`:

```dart
Habbit withAck(DateTime now) {
  return _copyWith(
    events: List.unmodifiable([..._events, Ack(occuredOn: now)]),
  );
}
```

*Dependency Injection*

Контейнер HabbitsContainer использует инъекцию зависимостей для функций `currentDateTime()` и `nextHabbitId()`, что обеспечивает тестируемость кода.

*Controller Pattern*

Интерфейс HabbitsController определяет контракт для взаимодействия UI с бизнес-логикой, что обеспечивает слабую связанность компонентов.

*Структура данных Habbit*

Для корректной работы приложения требуется описать структуру Habbit. Она состоит из следующих полей:

- *id* — уникальный идентификатор привычки (int)
- *name* — название привычки (String)
- *icon* — визуальная иконка из перечисления HabbitIcon
- *createdAt* — дата создания привычки (DateTime)
- *targetDays* — целевое количество дней для формирования привычки (int)
- *\_events* — список действий пользователя (List<HabbitAction>)

Класс Habbit предоставляет следующие методы:
- `withAck(DateTime)` — добавление отметки о выполнении
- `withBreak(DateTime)` — добавление отметки о пропуске
- `withName(String)` — изменение названия
- `withIcon(HabbitIcon)` — изменение иконки
- `withTargetDays(int)` — изменение целевого количества дней

Вычисляемые свойства:
- `currentProgress` — текущий прогресс (acks - breaks)
- `isGoalReached` — достигнута ли цель
- `currentAcks` — количество выполнений
- `currentBreaks` — количество пропусков

== Разработка виджетов

Виджеты являются основными строительными блоками пользовательского интерфейса приложения. В рамках данного проекта разработаны три ключевых виджета, обеспечивающих отображение и взаимодействие с привычками.

*Интерфейс HabbitsController*

HabbitsController представляет собой абстрактный интерфейс, определяющий контракт взаимодействия между UI-компонентами и бизнес-логикой приложения. Данный подход соответствует принципу инверсии зависимостей (Dependency Inversion Principle) и обеспечивает слабую связанность компонентов.

Интерфейс определяет следующие методы:

*Операции с привычками:*
- `ackHabbit({required int habbitId})` — отметка выполнения привычки
- `breakHabbit({required int habbitId})` — отметка срыва привычки
- `removeHabbit({required int habbitId})` — удаление привычки
- `addHabbit({required String name, required HabbitIcon icon, required int targetDays})` — добавление новой привычки
- `editHabbit({...})` — редактирование существующей привычки

*Навигация между экранами:*
- `showHabbitFormScreen({Habbit? habbit})` — переход к форме создания/редактирования
- `showHabbitsListScreen()` — переход к списку привычек
- `showHabbitStatsScreen({required int habbitId})` — переход к статистике

*Доступ к данным:*
- `habbits` — геттер для получения списка привычек

#listing(
  file: "../lib/features/widgets/habbits_controller.dart",
  caption: [Интерфейс HabbitsController],
) <lst:habbits-controller>

Реализация интерфейса показана в @lst:habbits-controller. Данный интерфейс реализуется контейнером состояния HabbitsContainer, что позволяет виджетам работать с абстракцией, а не с конкретной реализацией.

*Виджет HabbitsList*

HabbitsList — это виджет для отображения списка привычек. Он представляет собой статический компонент (StatelessWidget), который получает контроллер через конструктор и делегирует ему всю логику работы с данными.

*Основные характеристики:*
- Использует `ListView.builder` для эффективной отрисовки больших списков
- Принимает экземпляр HabbitsController для доступа к данным и операциям
- Создает виджет HabbitItem для каждого элемента списка
- Использует ValueKey для корректной идентификации элементов при перестроении

#listing(
  file: "../lib/features/widgets/habbits_list.dart",
  caption: [Виджет HabbitsList],
) <lst:habbits-list>

Реализация виджета показана в @lst:habbits-list. Виджет следует принципу единственной ответственности — его задача только отображать список, передавая управление отдельными элементами специализированному виджету HabbitItem.

*Виджет HabbitItem*

HabbitItem — это наиболее сложный виджет, отвечающий за отображение одной привычки в списке. Он содержит визуальное представление привычки и предоставляет интерактивные элементы для работы с ней.

*Структура виджета:*

+ *Контейнер Card* — обеспечивает визуальное выделение элемента с тенью и скругленными углами.
+ *InkWell* — добавляет интерактивность с эффектом ripple при нажатии. Открывает экран статистики при клике на карточку.
+ *Левая часть (иконка):*
  - Цветной контейнер с иконкой привычки
  - Метод `_getIconData()` преобразует тип HabbitIcon в IconData из Material Icons
+ *Центральная часть (информация):*
  - Название привычки (жирным шрифтом)
  - Кнопка редактирования рядом с названием
  - Целевое количество дней
  - Текущий прогресс (выполнения / цель)
  - Количество срывов (красным цветом)

+ *Правая часть (действия):*
- Кнопка срыва (красный крестик) — вызывает `controller.breakHabbit()`
- Кнопка подтверждения (зеленая галочка) — вызывает `controller.ackHabbit()`
- Обе кнопки отключаются при достижении цели (`isGoalReached`)

#listing(
  file: "../lib/features/widgets/habbit_item.dart",
  caption: [Виджет HabbitItem],
) <lst:habbit-item>

Реализация виджета показана в @lst:habbit-item.

*Ключевые особенности реализации:*

- *Адаптивная блокировка действий* — кнопки ack и break автоматически отключаются при достижении цели
- *Визуальная обратная связь* — использование цветов для обозначения действий (зеленый для успеха, красный для срыва)
- *Семантическая доступность* — все интерактивные элементы имеют tooltip для улучшения UX
- *Делегирование логики* — виджет не содержит бизнес-логики, а только вызывает методы контроллера

== Создание экранных форм

Приложение состоит из трех основных экранов, каждый из которых отвечает за конкретную функциональность и обеспечивает интуитивное взаимодействие с пользователем.

*Экран списка привычек (HabbitsListScreen)*

HabbitsListScreen — основная точка входа в приложение, представляющая собой главный экран со списком всех привычек пользователя.

*Назначение экрана:*
- Отображение всех активных привычек пользователя
- Быстрый доступ к добавлению новой привычки
- Навигация к детальной статистике при клике на привычку
- Предоставление возможности отметить выполнение или срыв привычки

*Компоненты экрана:*

- *Scaffold* — базовая структура экрана с AppBar и FloatingActionButton
- *AppBar* — содержит заголовок "Привычки" с фирменным цветом темы
- *body* — содержит виджет HabbitsList, который отображает список привычек
- *FloatingActionButton* — кнопка добавления новой привычки с иконкой "плюс"

Экран реализован как StatelessWidget, так как не содержит собственного изменяемого состояния. Все данные и операции делегируются контроллеру, переданному через конструктор.

#listing(
  file: "../lib/features/screens/habbits_list_screen.dart",
  caption: [Экран списка привычек],
) <lst:habbits-list-screen>

Реализация экрана показана в @lst:habbits-list-screen.

*Особенности реализации:*
- Использует цветовую схему из текущей темы приложения
- FloatingActionButton передает `null` в качестве параметра habbit, что означает создание новой привычки
- Экран полностью зависит от HabbitsController, что обеспечивает гибкость в изменении реализации состояния

*Экран формы привычки (HabbitFormScreen)*

HabbitFormScreen — экран для создания новой привычки или редактирования существующей. Поддерживает два режима работы: создание (когда editingHabbit = null) и редактирование (когда передан существующий объект Habbit).

*Назначение экрана:*
- Ввод названия привычки
- Выбор визуальной иконки из предустановленного набора
- Установка целевого количества дней
- Валидация введенных данных перед сохранением

*Структура формы:*

*1. AppBar с элементами управления:*
- Кнопка "Назад" — возврат к списку привычек
- Заголовок "Добавление привычки"
- Кнопка "Готово" (галочка) — активна только при валидной форме

*2. Поле ввода названия (TextField):*
- Лейбл "Название привычки"
- Плейсхолдер "Например: Пробежка"
- Обработчик `onChanged` для обновления состояния валидации

*3. Секция выбора иконки (Wrap с GestureDetector):*
- 5 предустановленных иконок (бег, чтение, отказ от курения, спорт, вода)
- Визуальное выделение выбранной иконки цветом и рамкой
- Использование Material Design Icons

*4. Поле ввода целевых дней (TextField):*
- Числовая клавиатура (keyboardType: TextInputType.number)
- Суффикс "дней" для понятности
- Плейсхолдер "Например: 30"

*Валидация формы:*

Форма считается валидной, если:
- Название не пустое (`_nameController.text.isNotEmpty`)
- Выбрана иконка (`_selectedIcon != null`)
- Введено положительное целое число дней

Кнопка сохранения активируется только при валидной форме через геттер `_isFormValid`.

#listing(
  file: "../lib/features/screens/habbit_form_screen.dart",
  caption: [Экран формы привычки],
) <lst:habbit-form-screen>

Реализация экрана показана в @lst:habbit-form-screen.

*Особенности реализации:*
- Использует StatefulWidget для управления локальным состоянием формы
- TextEditingController для управления текстовыми полями
- Правильная очистка ресурсов в методе `dispose()`
- Инициализация полей при редактировании в методе `initState()`
- Метод `_submitForm()` различает создание и редактирование по наличию `editingHabbit`

*Экран статистики привычки (HabbitStatsScreen)*

HabbitStatsScreen — экран детальной информации о конкретной привычке, включающий статистические данные и историю всех событий.

*Назначение экрана:*
- Визуализация прогресса выполнения привычки
- Отображение ключевых метрик (цель, прогресс, подтверждения, срывы)
- Показ истории всех событий (acks и breaks) с временными метками
- Визуальная индикация достижения цели

*Компоненты экрана:*

*1. Информационная карточка (Card):*
- Название привычки крупным шрифтом
- Четыре статистических показателя в ряд с иконками:
  - Цель (синяя иконка флага)
  - Прогресс (зеленая иконка роста)
  - Подтверждений (зеленая галочка)
  - Срывов (красный крестик)
- Прогресс-бар (LinearProgressIndicator) с цветовой индикацией
- Текстовый процент выполнения или сообщение о достижении цели

*2. История событий (ListView):*
- Заголовок "История событий"
- Список всех событий в обратном хронологическом порядке
- Каждое событие отображается в Card с иконкой, типом и временем
- Пустое состояние "Пока нет событий" для привычек без активности

*Вспомогательные методы:*

- `_formatDate()` — форматирование даты и времени в читаемый вид
- `_buildStatItem()` — создание виджета статистического показателя

#listing(
  file: "../lib/features/screens/habbit_stats_screen.dart",
  caption: [Экран статистики привычки],
) <lst:habbit-stats-screen>

Реализация экрана показана в @lst:habbit-stats-screen.

*Особенности реализации:*
- Цвет прогресс-бара меняется на зеленый при достижении цели
- События отображаются в обратном порядке (последние сверху)
- Использование типов Ack и Break для различения событий
- Адаптивное отображение процента прогресса с ограничением до 100%
- Семантическая цветовая схема: зеленый для успеха, красный для срывов, синий для целей

== Реализация логики приложения

Центральным элементом архитектуры приложения является HabbitsContainer — контейнер состояния, реализующий интерфейс HabbitsController и управляющий всей бизнес-логикой приложения.

*Архитектура контейнера состояния*

HabbitsContainer представляет собой StatefulWidget, который:
- Хранит список всех привычек пользователя
- Управляет навигацией между экранами
- Предоставляет методы для операций с привычками
- Обеспечивает инъекцию зависимостей для тестируемости

*Основное состояние:*
- `_habbits: List<Habbit>` — список всех привычек
- `_currentScreen: Screen` — текущий отображаемый экран
- `_selectedHabbitId: int?` — идентификатор выбранной привычки для просмотра/редактирования

*Инъецируемые зависимости:*
- `currentDateTime: DateTime Function()` — функция получения текущего времени
- `nextHabbitId: int Function()` — функция генерации уникального идентификатора

Такой подход позволяет легко тестировать логику приложения, подставляя моковые реализации функций времени и генерации ID.

*Операции с привычками*

*Добавление привычки (addHabbit):*

Создает новый объект Habbit с уникальным ID и текущим временем создания, добавляет его в список. Метод вызывается из формы создания привычки после валидации данных.

*Редактирование привычки (editHabbit):*

Находит привычку по ID и применяет последовательно методы изменения: `withName()`, `withTargetDays()`, `withIcon()`. Благодаря иммутабельности Habbit создается новый экземпляр с обновленными данными.

*Отметка выполнения (ackHabbit):*

Находит привычку и вызывает метод `withAck()`, передавая текущее время. Метод создает новый объект Ack и добавляет его в историю событий. Если цель уже достигнута, генерируется исключение.

*Отметка срыва (breakHabbit):*

Аналогично ackHabbit, но создает объект Break. Увеличивает счетчик срывов, что влияет на расчет прогресса (прогресс = acks - breaks).

*Удаление привычки (removeHabbit):*

Фильтрует список, исключая привычку с указанным ID. Метод не используется в текущей версии UI, но предоставлен интерфейсом для будущего расширения.

*Вспомогательный метод `_exchange`:*

Принимает ID привычки и функцию-мутацию, находит привычку по индексу и заменяет ее на результат применения мутации. Используется внутри ackHabbit, breakHabbit и editHabbit для избежания дублирования кода.

*Навигация между экранами*

Приложение использует ручную навигацию без использования Flutter Navigator. Это упрощает управление состоянием и делает поток данных более предсказуемым.

*Методы навигации:*

- `showHabbitsListScreen()` — переключает на список привычек, сбрасывает выбранную привычку
- `showHabbitFormScreen({Habbit? habbit})` — переключает на форму, устанавливает ID для редактирования
- `showHabbitStatsScreen({required int habbitId})` — переключает на статистику, запоминает ID привычки

Метод `build()` использует switch-выражение для выбора виджета в зависимости от `_currentScreen`:

```dart
switch (_currentScreen) {
  case Screen.HabbitsList:
    return HabbitsListScreen(controller: this);
  case Screen.HabbitForm:
    return HabbitFormScreen(habbits: this, editingHabbit: habbit);
  case Screen.HabbitStats:
    return HabbitStatsScreen(habbit: habbit!, controller: this);
}
```

#listing(
  file: "../lib/features/state/habbits_container.dart",
  caption: [Контейнер состояния HabbitsContainer],
) <lst:habbits-container>

Реализация контейнера состояния показана в @lst:habbits-container.

*Преимущества реализации*

*Центр управления состоянием:*

Все изменения данных проходят через единую точку (HabbitsContainer), что упрощает отладку и понимание потока данных.

*Иммутабельность данных:*

Использование иммутабельных структур Habbit предотвращает случайные изменения данных и упрощает отслеживание изменений состояния.

*Разделение ответственности:*

Экраны и виджеты не содержат бизнес-логики, а только отображают данные и вызывают методы контроллера.

== Выполнение практической работы №5

В рамках практической работы №5 было реализовано полнофункциональное приложение для отслеживания привычек с использованием фреймворка Flutter. Приложение демонстрирует применение базовых принципов разработки мобильных приложений и управления состоянием.

*Запуск и тестирование приложения*

Для запуска приложения использовалась команда `flutter run`. Приложение было протестировано на различных сценариях использования для проверки корректности работы всех функций. Ниже представлена визуальная демонстрация основных возможностей приложения.

*Демонстрация работы приложения*

При первом запуске приложения пользователь видит пустой экран с сообщением об отсутствии привычек и кнопкой для добавления новой привычки, как показано на #r(<fig:empty-screen>).

#picture(
  path: img("no_habbits_list_screen"),
  caption: [Главный экран приложения без привычек],
  width: 40%,
) <fig:empty-screen>

Для добавления новой привычки пользователь нажимает на кнопку с иконкой "плюс" (FloatingActionButton), после чего открывается форма создания привычки (#r(<fig:add-form-empty>)).

#picture(
  path: img("add_habbit_empty"),
  caption: [Форма создания новой привычки],
  width: 40%,
) <fig:add-form-empty>

Пользователь заполняет форму: вводит название привычки (например, "Утренняя пробежка"), выбирает иконку из предложенных вариантов и устанавливает целевое количество дней. Заполненная форма показана на #r(<fig:add-form-filled>).

#picture(
  path: img("add_habbit_1"),
  caption: [Заполненная форма для привычки "Утренняя пробежка"],
  width: 40%,
) <fig:add-form-filled>

После сохранения привычка появляется в списке с начальным прогрессом 0/30 (#r(<fig:habbit-added>)). Карточка привычки отображает название, иконку, целевое количество дней и текущий прогресс. Справа расположены кнопки для отметки срыва (красный крестик) и подтверждения выполнения (зеленая галочка).

#picture(
  path: img("habbit_1_added"),
  caption: [Список с добавленной привычкой (прогресс 0/30)],
  width: 40%,
) <fig:habbit-added>

При нажатии на зеленую галочку (кнопка ack) счетчик подтверждений увеличивается, и прогресс отображает новое значение (#r(<fig:habbit-ack>)). Это позволяет пользователю фиксировать факт выполнения привычки.

#picture(
  path: img("habbit_1_ack"),
  caption: [Отметка выполнения привычки (прогресс увеличился)],
  width: 40%,
) <fig:habbit-ack>

Если пользователь допустил срыв привычки, он может отметить это, нажав на красный крестик (кнопка break). При этом счетчик срывов увеличивается, а прогресс корректируется по формуле (acks - breaks), как показано на #r(<fig:habbit-break>).

#picture(
  path: img("habbit_1_break"),
  caption: [Отметка срыва привычки (счетчик breaks увеличился)],
  width: 40%,
) <fig:habbit-break>

Для изменения параметров привычки пользователь может нажать на кнопку редактирования (иконка карандаша) на карточке. Открывается форма редактирования с предзаполненными данными (#r(<fig:habbit-edit>)).

#picture(
  path: img("habbit_1_modify"),
  caption: [Редактирование существующей привычки],
  width: 40%,
) <fig:habbit-edit>

После сохранения изменений привычка обновляется с новыми параметрами. Прогресс автоматически пересчитывается относительно новой цели (#r(<fig:habbit-edited>)).

#picture(
  path: img("habbit_1_after_editing"),
  caption: [Привычка после изменения параметров],
  width: 40%,
) <fig:habbit-edited>

Когда пользователь достигает целевого количества дней, приложение визуально отображает достижение цели. Кнопки подтверждения и срыва становятся неактивными, предотвращая дальнейшие изменения (#r(<fig:goal-reached>)).

#picture(
  path: img("habbit_1_goal_reached"),
  caption: [Привычка с достигнутой целью (кнопки неактивны)],
  width: 40%,
) <fig:goal-reached>

Приложение поддерживает добавление множества привычек. Пользователь может создать вторую, третью и последующие привычки, используя ту же форму добавления. При наличии нескольких привычек список становится прокручиваемым, обеспечивая удобный доступ ко всем добавленным привычкам. На #r(<fig:scroll-list>) показан пример списка с несколькими привычками и возможностью вертикальной прокрутки.

#picture(
  path: img("show_scroll"),
  caption: [Список привычек с возможностью прокрутки],
  width: 40%,
) <fig:scroll-list>

Таким образом, приложение полностью реализует заявленную функциональность: создание и редактирование привычек, отслеживание прогресса, визуальную индикацию достижения целей и управление множественными привычками.

#pagebreak()
= Вывод

В ходе выполнения практической работы были освоены: создание структуры проекта и экранных форм, разработка логики и виджетов приложения.

Также была выбрана тема и подготовлено приложение, демонстрирующее реализацию бизнес-логики продукта. Было сформировано описание логики и выполняемых функций приложения, а также описания принципов его работы. Приложение включает в себя обработку пользовательского ввода, работу с данными и вывод информации. Приложение состоит из базовых элементов и строится на примитивных системах контроля состояния.

Исходный код приложения можно посмотреть по #link("https://github.com/burenotti/mirea-crossplatform-2/tree/burenin/practice-5")[ссылке на GitHub:

  https://github.com/burenotti/mirea-crossplatform-2/tree/burenin/practice-5]
