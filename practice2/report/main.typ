#import "./template/template.typ": *

#show: project.with(
  title: "Отчёт по практической работе №2",
  theme: "",
  department: "Математического обеспечения и стандартизации информационных технологий",
  course: "Разработка кроссплатформенных мобильных приложений",
  authors: (
    "Буренин А.А.",
  ),
  lecturer: "Шешуков Л.С.",
  lecturer_grade: "Старший преподаватель кафедры МОСИТ",
  group: "ИКБО-07-22",
  date: datetime.today(),
  add_toc: false,
)

#let img(path) = "./imgs/" + path + ".png"

= План работы
-  Знакомство со структурой стартового проекта;
- Изучение конфигурационного файла pubspec.yaml и его слепка
subspec.lock;
- Изучение lib директории и знакомство с основными принципами
работы с файлами в проекте;
- Знакомство с точкой запуска приложения main.dart, а так же с
виджетом приложения MaterialApp и виджетом страницы приложения
Scaffold;
- Выполнение практической работы №2;

= Ход работы

== Знакомство со структурой стартового проекта
Перед началом работы создадим проект только под платформу web с помощью команды на #ref(<flutter_create>, supplement: "листинге").

#listing(
  body: raw("flutter create practice2 --platforms web"),
  caption: "Команда создания проекта"
) <flutter_create>

Откроем проект в Visual Studio Code и посмотрим на файловую структуру, которая представлена на #ref(<file_tree>, supplement: "рисунке").

#picture(
  path: img("file_tree"),
  caption: "файловая структура проекта на flutter",
  width: 40%,
) <file_tree>

Все директории имеют свои назначение (предназначение), которые можно разбить на 3 группы: сервисные директории (.dart_tool, .idea, и все другие, начинающиеся с «.», build), директории нативного блока (android, ios, linux, macos, web, windows) и директории разработки (lib, test, assets и другие создаваемые разработчиком директории).

Помимо директорий, стартовый проект содержит ряд файлов, используемых для настройки проекта. Рассмотрим ряд из них:
- pubspec.yaml и pubspec.lock – основной файл конфигурации проекта;
- analysis_option.yaml – файл конфигурации статического анализатора;
- README.md – файл с публичным описанием задач и смысла проекта.

== Изучение конфигурационного файла pubspec.yaml и его слепка pubspec.lock.
Файлы pubspec.yaml и pubspec.lock используются флаттером для конфигурации проекта и управления зависимостями, основным файлом является pubspec.yaml, в нем перечисляются прямые зависимости и настройки проекта, его структура представлена на #ref(<pubspec_yaml>, supplement: "рисунке").

#picture(
  path: img("pubspec_yaml"),
  caption: "Содержимое файла pubspec.yaml",
  width: 50%
) <pubspec_yaml>

На верхнем уровне файла можно увидеть основные параметры:
- Name – параметр, устанавливающий название проекта;
- Description – параметр, устанавливающий приватное описание проекта;
- Publish_to – параметр, задающий возможность открытого
распространения данного проекта. Значение «none» означает, что данный
проект не планируется к открытому распространению как зависимость;
- Version – устанавливает нынешнюю версию приложения. Чаще всего
используется трехуровневая версионирование с использованием номера
сборки;
- Dependencies – зависимости проекта от других пакетов, проектов или
зависимостей, используемых в проекте и добавляемых в итоговую сборку
приложения;
- Dev_dependencies – зависимости проекта от других пакетов, проектов
или зависимостей, используемых в проекте, но не добавляемых в итоговую
сборку приложения;
- Flutter – установка зависимостей проекта от других источников.

Файл pubspec.lock является генерируемым, в нем располагается результат разрешения зависимостей, в том числе транзитивных, указывается источник, откуда зависимость загружена, хэш-сумма и точная версия. Содержимое этого файла представлено на #ref(<pubspec_lock>, supplement: "рисунке")

#picture(
  path: img("pubspec_lock"),
  caption: "Содержимое файла pubspec.lock",
  width: 40%
) <pubspec_lock>


== Изучение lib директории и знакомство с основными принципами работы с файлами в проекте.

оты с файлами в проекте.
В папке lib хранятся все файлы, которые создаются разработчиком при
работе над проектом. Для обеспечения порядка и удобства дальнейшей работы
с кодом необходимо придерживаться определённых правил при создании
файлов и подкаталогов.
Существует два основных метода организации структуры проекта:
- Feature First — структура строится на основе функциональных
возможностей (фич) приложения. В папке lib создаётся каталог feature, внутри
которого формируются подкаталоги для каждой разрабатываемой функции.
- Screen First — организация структуры происходит исходя из экранов
приложения.
Выбор подхода остаётся на усмотрение разработчика, однако в
сообществе Flutter-разработчиков более распространённым является метод
Feature First.

==  Знакомство с точкой запуска приложения main.dart, а так же с виджетом приложения MaterialApp и виджетом страницы приложения Scaffold.

Виджеты являются фундаментальным строительным блоком при
разработке приложений во Flutter. Фреймворк предоставляет обширную
библиотеку готовых компонентов, которые можно использовать для создания
пользовательского интерфейса.
В арсенале Flutter имеется множество стандартных виджетов, однако
разработчики обладают широкими возможностями для творчества:
- Создание собственных кастомных виджетов
- Настройка внешнего вида существующих компонентов
- Реализация нестандартных способов отрисовки
- Адаптация под конкретные задачи проекта
Несмотря на возможности кастомизации, базовая разработка в Flutter
преимущественно опирается на использование стандартных виджетов
фреймворка, что обеспечивает:
- Стабильность работы приложения
- Соответствие общепринятым паттернам
- Оптимизированную производительность
7
Важно отметить, что создание любого Flutter-приложения невозможно
без использования виджетов. Для инициализации приложения предусмотрены
два основных корневых виджета:
- MaterialApp — реализует дизайн-систему Material Design от Google,
подходит для создания кроссплатформенных приложений
- CupertinoApp — следует гайдлайнам iOS, используется для создания
приложений с нативным внешним видом под экосистему Apple
В большинстве случаев разработчики выбирают MaterialApp в качестве
корневого виджета, так как:
- Обеспечивает универсальность интерфейса
- Имеет более широкую поддержку
- Подходит для мультиплатформенной разработки
- Не требует дополнительной адаптации под разные платформы
Выбор CupertinoApp оправдан только в случаях, когда критически важно
точное соответствие стилю iOS и использование специфичных паттернов
взаимодействия этой операционной системы.
Сигнатура Widget-а MaterialApp представлена на #ref(<myapp_before>)

#picture(
  path: img("myapp_before"),
  caption: "Виджет MaterialApp",
) <myapp_before>

Разберем фрагмент кода досконально:
Аннотация \@override указывает компилятору на переопределение
метода родительского класса. В данном случае переопределяется метод build()
класса State, что необходимо для корректной работы виджета.8
Метод build() — основной метод для создания пользовательского
интерфейса. Принимает параметр BuildContext, который содержит
информацию о расположении виджета в дереве виджетов, и возвращает
отображаемый на экране виджет.
Виджет MaterialApp служит корневым виджетом для инициализации
приложения в стиле Material Design, обеспечивая базовую структуру и
функциональность.
Атрибуты виджета MaterialApp:
- title задаёт название приложения, которое отображается в заголовке
вкладки браузера при запуске в веб-версии и используется как метка
приложения.
- theme определяет общую тему приложения, включая настройки стилей,
цветов и типографики. В данном случае используется ThemeData.
- colorScheme определяет цветовую схему приложения, создаётся на
основе seedColor (базового цвета), автоматически генерируя гармоничные
оттенки для различных элементов интерфейса.
- home указывает стартовый экран приложения. В данном случае это
виджет MyHomePage, а ключевое слово const указывает на неизменяемость
виджета.
- title в MyHomePage передаёт заголовок для домашней страницы,
являясь параметром пользовательского виджета и используясь для
отображения заголовка на странице.
После того, как приложение добавлено и в него требуется добавить
страницу приложения. Для отрисовки страницы используется стандартный
Widget Scaffold. Данный виджет отвечает за отрисовку страницы и имеет
сигнатуру для удобного ее конфигурации. Сигнатуру Widget-а Scaffold можно
изучить на #ref(<widget_before>, supplement: "рисунке")

#picture(
  path: img("widget_before"),
  caption: "Виджет MyHomePage",
) <widget_before>

Рассмотрим структуру фрагмента кода:
Scaffold — базовый виджет для создания структуры экрана,
включающий основные элементы интерфейса.
Основные компоненты:
- appBar — верхняя панель приложения:
- backgroundColor — цвет фона панели, взятый из текущей темы;
- title — заголовок панели, отображающий значение widget.title.
- body — основное содержимое экрана:
- Center — виджет для центрирования содержимого;
- Column — вертикальный контейнер для размещения элементов;
- mainAxisAlignment — выравнивание элементов по вертикали;

- children — список виджетов:
- Text — статический текст с пояснением;
- Text — динамический текст, отображающий значение счётчика с
заданным стилем.
- floatingActionButton — плавающая кнопка действия:
- onPressed — обработчик нажатия;
- tooltip — всплывающая подсказка;
- child — иконка кнопки.

== Выполенние практической работы 2
Так как при выполнении работы мы убираем функционал счётчика, соответственно нам более не нужно состояние, поэтому мы можем изменить тип виджета MyHomePage на StatelessWidget, это позволит упростить его. Результат преобразования виден на #ref(<widget_after>, supplement: "рисунке").

Кнопку было принято решение не убирать, чтобы не изменять дизайн существующего приложения, однако функция обратного вызова в параметре onPressed была изменена на пустую.

#picture(
  path: img("widget_after"),
  caption: "Виджет MyHomePage",
  width: 65%
) <widget_after>

Так же были добавлены параметры studentGroup и studentName, которые передаются в конструктор при создании виджета.

В соответствии с изменившемся интерфейсом виджета MyHomePage был изменен виджет MyApp, результат модифиакции предствален на  #ref(<myapp_after>, supplement: "рисунке").

#picture(
  path: img("myapp_after"),
  caption: "Виджет MyHomePage",
  width: 70%
) <myapp_after>

= Вывод

В результате работы была разобрана структура проекта на flutter, а так же произведена базовая модификация проекта. Результаты работы можно посмотреть в соответствующем Pull Request на GitHub: https://github.com/burenotti/mirea-crossplatform-2/pull/1